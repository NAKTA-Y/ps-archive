## 문제풀이 시간

23분

## 성능 요약

메모리: 22760 KB

시간: 308 ms

## 문제 설명

도시에는 N개의 빌딩이 있다.

빌딩 관리인들은 매우 성실 하기 때문에, 다른 빌딩의 옥상 정원을 벤치마킹 하고 싶어한다.

i번째 빌딩의 키가 hi이고, 모든 빌딩은 일렬로 서 있고 오른쪽으로만 볼 수 있다.

i번째 빌딩 관리인이 볼 수 있는 다른 빌딩의 옥상 정원은 i+1, i+2, .... , N이다.

그런데 자신이 위치한 빌딩보다 높거나 같은 빌딩이 있으면 그 다음에 있는 모든 빌딩의 옥상은 보지 못한다.

예) N=6, H = {10, 3, 7, 4, 12, 2}인 경우

```
             =
 =           =
 =     -     =
 =     =     =        -> 관리인이 보는 방향
 =  -  =  =  =
 =  =  =  =  =  =
10  3  7  4  12 2     -> 빌딩의 높이
[1][2][3][4][5][6]    -> 빌딩의 번호
```

- 1번 관리인은 2, 3, 4번 빌딩의 옥상을 확인할 수 있다.
- 2번 관리인은 다른 빌딩의 옥상을 확인할 수 없다.
- 3번 관리인은 4번 빌딩의 옥상을 확인할 수 있다.
- 4번 관리인은 다른 빌딩의 옥상을 확인할 수 없다.
- 5번 관리인은 6번 빌딩의 옥상을 확인할 수 있다.
- 6번 관리인은 마지막이므로 다른 빌딩의 옥상을 확인할 수 없다.

따라서, 관리인들이 옥상정원을 확인할 수 있는 총 수는 3 + 0 + 1 + 0 + 1 + 0 = 5이다.

## 조건

첫 번째 줄에 빌딩의 개수 N이 입력된다.(1 ≤ N ≤ 80,000)

두 번째 줄 부터 N+1번째 줄까지 각 빌딩의 높이가 h 입력된다. (1 ≤ h ≤ 1,000,000,000)

## 입력

> 예제 입력 1
> 

```
6
10
3
7
4
12
2
```

## 출력

> 예제 출력 1
> 

```
5
```

## 문제 풀이

각각의 빌딩 높이를 스택에 넣어두고, 해당 빌딩을 어떤 빌딩이 볼 수 있는지 그 수를 더하면 되는 문제이다.

물론 스택이 아닌, 배열로도 풀이가 가능하지만, 조건을 봤을 때, 빌딩의 개수는 최대 80,000개 이므로 빌딩의 높이가 주어질 때 마다 배열 내의 요소를 모두 비교하면 O(n^2)으로 시간 초과가 나버린다.

따라서, 스택을 활용하여 빌딩의 높이가 주어지면, 해당 빌딩의 높이보다 같거나, 작은 빌딩들을 모두 pop 해버리고 스택에 해당 빌딩의 높이를 넣기 전에 스택의 크기를 결과값에 더해주면 해당 빌딩을 볼 수 있는 빌딩의 수를 구해줄 수 있다.

문제 로직을 잘 짜고나서, 2번의 실패를 겪었는데 그 이유는 결과값 타입을 고려하지 않아서 실패를 했다. 만약, 빌딩이 80,000부터 1까지 나열되어 있다면, 답은 79,999부터 1까지 더한 값이 될 것이다. 그 값은 3,199,960,000으로 int 타입의 범위를 초과하기 때문에 엉뚱한 답이 나와버려 실패를 했던 것이다.

문제의 조건을 확인하고 나올 수 있는 최댓값과 최솟값을 고려하여 타입을 지정하는 버릇을 들여야겠다.

## 테스트케이스

> 테스트케이스 1
> 

```
5
1
2
3
4
5
```

> 테스트케이스 2
> 

```
5
5
4
3
2
1
```

> 테스트케이스 3
> 

```
5
3
2
2
1
1
```

> 테스트케이스 4
> 

```
5
1
1
1
1
1
```

## 코드

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.Stack

fun main() {
    BufferedReader(InputStreamReader(System.`in`)).use {
        var result = 0L
        val stack = Stack<Int>()
        val n = readln().toInt()
        for (i in 0 until n) {
            val height = readln().toInt()

            while (stack.isNotEmpty() && height >= stack.peek()) {
                stack.pop()
            }

            result += stack.size
            stack.push(height)
        }

        println(result)
    }
}
```
